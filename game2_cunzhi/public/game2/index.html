<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game2 - 耐受度/寸止测试</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: "PingFang SC", system-ui, sans-serif; background: #111827; color: #f9fafb; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    .stage { display: grid; grid-template-columns: 280px 1fr; gap: 16px; }
    .avatar { background: linear-gradient(180deg,#374151,#1f2937); border-radius: 14px; min-height: 420px; position: relative; overflow: hidden; }
    .avatar::after { content: "二次元立绘"; position:absolute; inset:auto 0 16px 0; text-align:center; opacity:.7; }
    .dialog { background: #1f2937; border-radius: 14px; padding: 14px; min-height: 180px; }
    .subtitle { min-height: 52px; color: #bfdbfe; }
    .buttons { display: grid; grid-template-columns: repeat(3,minmax(90px,1fr)); gap: 10px; margin-top: 12px; }
    button { border: 0; border-radius: 10px; padding: 12px; font-size: 16px; font-weight: 700; cursor: pointer; }
    .primary { background: #2563eb; color: #fff; }
    .danger { background: #dc2626; color: #fff; }
    .soft { background: #475569; color: #fff; }
    .panel { margin-top: 14px; background: #1f2937; border-radius: 14px; padding: 12px; }
    .always-stop { position: fixed; right: 20px; bottom: 20px; z-index: 9999; }
    input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #334155; background: #0f172a; color: #fff; margin-top: 8px; }
    .log { max-height: 180px; overflow: auto; background: #0b1220; padding: 10px; border-radius: 8px; font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Game2（耐受度/寸止测试）</h1>
    <div class="panel">
      <label>UID<input id="uid" placeholder="请输入 uid" /></label>
      <label>SessionId<input id="sessionId" placeholder="建议使用时间戳，如 g2_1730000000" /></label>
      <div class="buttons">
        <button class="primary" id="btnUnlock">解锁音频</button>
        <button class="primary" id="btnStart">开始</button>
        <button class="soft" id="btnSoftReset">Soft Reset</button>
      </div>
    </div>

    <div class="stage" style="margin-top: 16px;">
      <div class="avatar"></div>
      <div>
        <div class="dialog">
          <div id="subtitle" class="subtitle"></div>
          <div class="buttons" id="actionButtons"></div>
        </div>
        <div class="panel"><pre class="log" id="log"></pre></div>
      </div>
    </div>
  </div>

  <button class="danger always-stop" id="btnEmergency">急停（立即 stop）</button>

  <script>
    const config = {
      apiBase: '/api/game2',
      schemaVersion: 1,
      gameVersion: '1.0.0',
      safetyTimeoutMs: 30000,
      flow: {
        levels: [1,2,3,4,5],
        adaptMs: 2000,
        evalMs: 3000,
        restMs: 20000,
        roundRestMs: 20000,
        minRounds: 4,
        maxRounds: 6,
      }
    };

    const state = {
      uid: '', sessionId: '', seq: 1,
      audioUnlocked: false,
      speechReady: 'speechSynthesis' in window,
      safetyTimer: null,
      roundStartAt: 0,
      rounds: [],
      flow: 'IDLE'
    };

    const $ = (id) => document.getElementById(id);
    const logEl = $('log');
    const subtitleEl = $('subtitle');
    const actionButtonsEl = $('actionButtons');

    function log(...args) {
      logEl.textContent += `[${new Date().toLocaleTimeString()}] ${args.join(' ')}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function api(path, body, fast = false) {
      const ctrl = new AbortController();
      const timer = setTimeout(() => ctrl.abort(), fast ? 1800 : 8000);
      try {
        const res = await fetch(config.apiBase + path, {
          method: 'POST', headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body), signal: ctrl.signal,
        });
        const json = await res.json();
        if (!res.ok || !json.ok) throw new Error(json.message || `HTTP ${res.status}`);
        return json;
      } finally { clearTimeout(timer); }
    }

    class DialogueEngine {
      constructor() { this.running = false; }
      async typewrite(text, speed = 26) {
        subtitleEl.textContent = '';
        for (const ch of text) {
          subtitleEl.textContent += ch;
          await new Promise(r => setTimeout(r, speed));
        }
      }
      renderButtons(btns) {
        actionButtonsEl.innerHTML = '';
        btns.forEach(({ label, onClick, cls='primary' }) => {
          const b = document.createElement('button'); b.className = cls; b.textContent = label; b.onclick = onClick;
          actionButtonsEl.appendChild(b);
        });
      }
    }

    const engine = new DialogueEngine();

    async function speak(text) {
      // 三层降级：1. 音频文件 2. TTS 3. 仅字幕
      if (state.audioUnlocked) {
        try {
          const beep = new Audio('/assets/beep.mp3');
          await beep.play();
          return;
        } catch (_) {}
      }
      if (state.speechReady) {
        try {
          speechSynthesis.cancel();
          const u = new SpeechSynthesisUtterance(text);
          u.lang = 'zh-CN';
          speechSynthesis.speak(u);
          return;
        } catch (_) {}
      }
    }

    async function say(text) {
      await engine.typewrite(text);
      await speak(text);
    }

    function nextSeq() { return state.seq++; }

    function ensureIdent() {
      state.uid = $('uid').value.trim();
      state.sessionId = $('sessionId').value.trim() || `g2_${Date.now()}`;
      $('sessionId').value = state.sessionId;
      if (!state.uid) throw new Error('请先填写 uid');
    }

    function armSafetyTimeout() {
      clearTimeout(state.safetyTimer);
      state.safetyTimer = setTimeout(() => emergencyStop('safety_timeout'), config.safetyTimeoutMs);
    }

    async function safeInterrupted(by) {
      try {
        await api('/session/progress', {
          uid: state.uid, sessionId: state.sessionId, seq: nextSeq(), action: 'interrupted',
          byVisibility: by === 'visibilitychange', byApi: by === 'api_error', reason: by,
        }, true);
      } catch (e) { log('interrupted 上报失败:', e.message); }
    }

    async function emergencyStop(reason='manual') {
      try { ensureIdent(); } catch { return; }
      log('触发急停:', reason);
      await safeInterrupted(reason === 'manual' ? 'api_error' : reason);
      try {
        await api('/session/complete', {
          uid: state.uid, sessionId: state.sessionId, seq: nextSeq(), status: 'complete_with_warning', reason,
        }, true);
      } catch (e) { log('急停 complete ACK 失败:', e.message); }
      state.flow = 'STOPPED';
      clearTimeout(state.safetyTimer);
      await say('已执行急停。请休息后再继续。');
    }

    async function runFlowA() {
      state.flow = 'A';
      for (const lv of config.flow.levels) {
        await say(`流程A：频率档位 ${lv}，2秒适应 + 3秒评价。`);
        await new Promise(r => setTimeout(r, config.flow.adaptMs + config.flow.evalMs));

        let score = await new Promise((resolve) => {
          engine.renderButtons([1,2,3,4,5].map(n => ({ label: `评分 ${n}`, onClick: () => resolve(n) })));
        });

        await api('/session/progress', { uid: state.uid, sessionId: state.sessionId, seq: nextSeq(), action: 'frequency_score', level: lv, score });
        await say(`已记录档位 ${lv} 评分 ${score}，休息 20 秒。`);
        await new Promise(r => setTimeout(r, config.flow.restMs));
      }

      const selectedFrequency = await new Promise((resolve) => {
        engine.renderButtons(config.flow.levels.map(lv => ({ label: `选择 ${lv}`, onClick: () => resolve(lv) })));
      });
      await api('/session/progress', { uid: state.uid, sessionId: state.sessionId, seq: nextSeq(), action: 'frequency_select', selectedFrequency });
      await say(`你最终选择了频率 ${selectedFrequency}。进入流程B。`);
    }

    async function runFlowB() {
      state.flow = 'B';
      state.rounds = [];

      for (let i=1;i<=config.flow.maxRounds;i++) {
        await say(`流程B 第 ${i} 轮开始，点击“寸止”进行 stop。`);
        state.roundStartAt = Date.now();
        armSafetyTimeout();

        await new Promise((resolve) => {
          engine.renderButtons([{ label: '寸止', cls: 'danger', onClick: resolve }]);
        });

        clearTimeout(state.safetyTimer);
        const elapsedSec = (Date.now() - state.roundStartAt) / 1000;
        state.rounds.push(elapsedSec);
        const resp = await api('/session/progress', {
          uid: state.uid, sessionId: state.sessionId, seq: nextSeq(), action: 'tolerance_stop', elapsedSec,
        });
        log(`第${i}轮 stop: ${elapsedSec.toFixed(2)}s, status=${resp.status}`);

        if (resp.status === 'complete' || resp.status === 'complete_with_warning') {
          await api('/session/complete', { uid: state.uid, sessionId: state.sessionId, seq: nextSeq(), status: resp.status }, true);
          await say(`流程结束。T_stable=${resp.state.flowB.T_stable ?? '-'}，T_guard=${resp.state.flowB.T_guard ?? '-'}。`);
          return;
        }

        await say('本轮结束，休息 20 秒。');
        await new Promise(r => setTimeout(r, config.flow.roundRestMs));
      }
    }

    async function startAll() {
      try {
        ensureIdent();
        const active = await fetch(`${config.apiBase}/session/active?uid=${encodeURIComponent(state.uid)}`).then(r => r.json());
        if (active?.session && active.session.id !== state.sessionId) {
          throw new Error(`发现未完成会话: ${active.session.id}（冲突）`);
        }

        await api('/session/start', { uid: state.uid, sessionId: state.sessionId, seq: nextSeq() });
        await say('会话开始。准备进入流程A。');
        await runFlowA();
        await runFlowB();
      } catch (e) {
        log('流程错误:', e.message);
        await safeInterrupted('api_error');
      }
    }

    $('btnUnlock').onclick = async () => {
      try {
        const a = new Audio();
        await a.play().catch(() => {});
        state.audioUnlocked = true;
        log('音频已解锁');
      } catch { log('音频解锁失败，将自动降级到 TTS/字幕'); }
    };
    $('btnStart').onclick = () => startAll();
    $('btnEmergency').onclick = () => emergencyStop('manual');
    $('btnSoftReset').onclick = async () => {
      try {
        ensureIdent();
        const resp = await api('/user/reset', { uid: state.uid, mode: 'soft' });
        log('soft reset:', JSON.stringify(resp));
      } catch (e) { log('soft reset 失败:', e.message); }
    };

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') {
        await emergencyStop('visibilitychange');
      }
    });
  </script>
</body>
</html>
